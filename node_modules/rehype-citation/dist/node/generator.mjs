import { visit } from 'unist-util-visit';
import fetch from 'cross-fetch';
import parse5 from 'parse5';
import { fromParse5 } from 'hast-util-from-parse5';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Captures normal citation in square bracket and in-text citation
 * Citation key start should start with a letter, digit, or _,
 * and contains only alphanumerics and single internal punctuation characters (:.#$%&-+?<>~/),
 *
 * e.g. [-@wadler1990], [@hughes1989, sec 3.4], [see @wadler1990; and @hughes1989, pp. 4]
 * and @wadler1990
 *
 * Group #1 - citation term without [] bracket e.g. -@wadler1990
 * Group #2 - in-text citation term e.g. @wadler1990
 *
 * \[([^[\]]*@[^[\]]+)\] for group #1
 * (?!\b)@([a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\-+?<>~]*) for group #2
 * Use (?!\b) to avoid email like address e.g. xyx@google.com
 * */
const citeExtractorRe = /\[([^[\]]*@[^[\]]+)\]|(?!\b)(@[a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\-+?<>~]*)/;
const citeKeyRe = /@([a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\-+?<>~]*)/;
const citeBracketRe = /\[.*\]/;

/**
 * @typedef CiteItem
 *   Cite item to be passed into citeproc-js
 * @property {string} [id]
 *   The id field is required
 * @property {string} [locator]
 *   A string identifying a page number or other pinpoint location or range within the resource;
 * @property {string} [label]
 *   Path to file
 * @property {string} [prefix]
 *   A string to print before this cite item
 * @property {string} [suffix]
 *   A string to print after this cite item
 * @property {boolean} [suppress-author]
 *   If true, author names will not be included in the citation output for this cite
 * @property {boolean} [author-only]
 *   If true, only the author name will be included in the citation output for this cite
 */
const locatorMapping = {
  book: 'book',
  'bk.': 'book',
  'bks.': 'book',
  chapter: 'chapter',
  'chap.': 'chapter',
  'chaps.': 'chapter',
  column: 'column',
  'col.': 'column',
  'cols.': 'column',
  figure: 'figure',
  'fig.': 'figure',
  'figs.': 'figure',
  folio: 'folio',
  'fol.': 'folio',
  'fols.': 'folio',
  number: 'number',
  'no.': 'number',
  'nos.': 'number',
  line: 'line',
  'l.': 'line',
  'll.': 'line',
  note: 'note',
  'n.': 'note',
  'nn.': 'note',
  opus: 'opus',
  'op.': 'opus',
  'opp.': 'opus',
  page: 'page',
  'p.': 'page',
  'pp.': 'page',
  paragraph: 'paragraph',
  'para.': 'paragraph',
  'paras.': 'paragraph',
  part: 'part',
  'pt.': 'part',
  'pts.': 'part',
  section: 'section',
  'sec.': 'section',
  'secs.': 'section',
  'sub verbo': 'sub verbo',
  's.v.': 'sub verbo',
  's.vv.': 'sub verbo',
  verse: 'verse',
  'v.': 'verse',
  'vv.': 'verse',
  volume: 'volume',
  'vol.': 'volume',
  'vols.': 'volume',
  '¶': 'paragraph',
  '¶¶': 'paragraph',
  '§': 'section',
  '§§': 'section'
};
/**
 * Parses a given citation string and return properties and entries required for cite-proc.
 * Adapted from https://github.com/Zettlr/Citr/blob/master/lib/citr.ts
 *
 * @param {string} citeString Cite string in the form of '[@item]' or '@item'
 * @return {[Object, CiteItem[]]} [properties, entries]
 */

const parseCitation = citeString => {
  /** @type {CiteItem[]} */
  let entries = [];
  let properties;

  if (citeBracketRe.test(citeString)) {
    properties = {
      noteIndex: 0
    }; // Handle citations in the form of [@item1; @item2]

    const citeItems = citeString.substr(1, citeString.length - 2).split(';');

    for (const citeItem of citeItems) {
      // Prefix is the portion before @ e.g. [see @item1] or an empty string
      let prefix = '';
      let locator = '';
      let label = 'page';
      let suffix = '';
      const citeChunk = citeItem.split('@');

      if (citeChunk.length === 1) {
        throw new Error('Cite key should be in the form of @key');
      } else if (citeChunk.length > 2) {
        throw new Error('More than one cite key @ detected, please separate keys with ;');
      }

      prefix += citeChunk[0];
      prefix = prefix.trim(); // If [-@item1], suppress author

      let suppressAuthor = citeItem.indexOf('@') > 0 && citeItem[citeItem.indexOf('@') - 1] === '-';
      if (suppressAuthor) prefix = prefix.substr(0, prefix.length - 1).trim(); // The citation key can be terminated with a comma or space

      let commaIndex = citeChunk[1].indexOf(',') + 1; // If the commaIndex is 0, this means there was no comma - check for space

      if (commaIndex === 0) commaIndex = citeChunk[1].indexOf(' ') + 1; // Pass undefined to extract everything

      if (commaIndex <= 0) commaIndex = undefined;
      const citeKey = citeItem.substr(citeItem.indexOf('@'), commaIndex).match(citeKeyRe)[0]; // We are left with the locator, suffix and label

      let afterKey = citeItem.split('@')[1].substr(citeKey.length).trim();
      if (afterKey[0] === ',') afterKey = afterKey.substr(1).trim(); // Locator should be in the form of 11-22, 33
      // Would not work form roman numerals or alphabetical sections

      const locatorMatch = afterKey.match(/(\d|-| |,)+/g);

      if (locatorMatch !== null) {
        locator = locatorMatch[0].trim(); // String before the locator is taken to be the label
        // Use heuristic from https://pandoc.org/MANUAL.html#citation-syntax to convert locator label to valid
        // Label has to be one of the following: https://docs.citationstyles.org/en/stable/specification.html#locators

        label = afterKey.split(locator)[0].trim();
        label = locatorMapping[label] || 'page'; // String after the locator is taken to be the suffix

        suffix = afterKey.split(locator)[1].trim();
      } else {
        // If no locator is found, entire string is assumed to be the suffix
        suffix = afterKey.trim();
      }

      entries.push({
        // Get the first capture group which returns the citekey without @
        id: citeItem.match(citeKeyRe)[1],
        locator,
        label,
        prefix,
        suffix,
        'suppress-author': suppressAuthor
      });
    }
  } else {
    // Single item in the form of @item1
    // See https://citeproc-js.readthedocs.io/en/latest/running.html#special-citation-forms
    properties = {
      noteIndex: 0,
      mode: 'composite'
    };
    entries = [citeString].map(str => ({
      id: str.match(citeKeyRe)[1]
    }));
  }

  return [properties, entries];
};

const readFile = async path => {
  if (isValidHttpUrl(path)) {
    return fetch(path).then(response => response.text()).then(data => data);
  } else {
    {
      return import('fs').then(fs => fs.readFileSync(path, 'utf8'));
    }
  }
};
/**
 * Check if valid URL
 * https://stackoverflow.com/questions/5717093/check-if-a-javascript-string-is-a-url
 *
 * @param {string} str
 * @return {boolean}
 */

const isValidHttpUrl = str => {
  let url;

  try {
    url = new URL(str);
  } catch (_) {
    return false;
  }

  return url.protocol === 'http:' || url.protocol === 'https:';
};
/**
 * Get bibliography by merging options and vfile data
 *
 * @param {import('./generator.js').Options} options
 * @param {import('vfile').VFile} file
 */

const getBibliography = async (options, file) => {
  var _file$data, _file$data$frontmatte;

  let bibliography = '';

  if (options.bibliography) {
    bibliography = options.bibliography; // @ts-ignore
  } else if (file != null && (_file$data = file.data) != null && (_file$data$frontmatte = _file$data.frontmatter) != null && _file$data$frontmatte.bibliography) {
    // @ts-ignore
    bibliography = file.data.frontmatter.bibliography; // If local path, get absolute path

    if (!isValidHttpUrl(bibliography)) {
      {
        bibliography = await import('path').then(path => path.join(options.path || file.cwd, bibliography));
      }
    }
  }

  return bibliography;
};
/**
 * Load CSL - supports predefined name from config.templates.data or http, file path (nodejs)
 *
 * @param {*} Cite cite object from citation-js
 * @param {string} format CSL name e.g. apa or file path to CSL file
 * @param {string} root optional root path
 */

const loadCSL = async (Cite, format, root = '') => {
  const config = Cite.plugins.config.get('@csl');

  if (!Object.keys(config.templates.data).includes(format)) {
    let cslPath = '';
    if (isValidHttpUrl(format)) cslPath = format;else {
      cslPath = await import('path').then(path => path.join(root, format));
    }

    try {
      config.templates.add('customCSL', await readFile(cslPath));
    } catch (err) {
      throw new Error(`Input CSL option, ${format}, is invalid or is an unknown file.`);
    }

    return 'customCSL';
  } else {
    return format;
  }
};
/**
 * Load locale - supports predefined name from config.locales.data or http, file path (nodejs)
 *
 * @param {*} Cite cite object from citation-js
 * @param {string} format locale name
 * @param {string} root optional root path
 */

const loadLocale = async (Cite, format, root = '') => {
  const config = Cite.plugins.config.get('@csl');

  if (!Object.keys(config.locales.data).includes(format)) {
    let localePath = '';
    if (isValidHttpUrl(format)) localePath = format;else {
      localePath = await import('path').then(path => path.join(root, format));
    }

    try {
      const file = await readFile(localePath);
      const xmlLangRe = /xml:lang="(.+)"/;
      const localeName = file.match(xmlLangRe)[1];
      config.locales.add(localeName, file);
      return localeName;
    } catch (err) {
      throw new Error(`Input locale option, ${format}, is invalid or is an unknown file.`);
    }
  } else {
    return format;
  }
};

/**
 * Convert HTML to HAST node
 *
 * @param {string} html
 */

const htmlToHast = html => {
  const p5ast = parse5.parseFragment(html);
  return fromParse5(p5ast).children[0];
};

const defaultCiteFormat = 'apa';
const permittedTags = ['div', 'p', 'span', 'li'];
/**
 * Generate citation using citeproc
 * This accounts for prev citations and additional properties
 *
 * @param {*} citeproc
 * @param {CiteItem[]} entries
 * @param {string} citationId
 * @param {any[]} citationPre
 * @param {Options} options
 * @param {*} [properties={ noteIndex: 0 }]
 * @return {*}
 */

const genCitation = (citeproc, entries, citationId, citationPre, options, properties = {
  noteIndex: 0
}) => {
  var _options$inlineClass;

  const c = citeproc.processCitationCluster({
    citationID: citationId,
    citationItems: entries,
    properties: properties
  }, citationPre.length > 0 ? citationPre : [], []); // c = [ { bibchange: true, citation_errors: [] }, [ [ 0, '(1)', 'CITATION-1' ] ]]

  const result = c[1].find(x => x[2] === citationId);
  const ids = `citation--${entries.map(x => x.id.toLowerCase()).join('--')}--${citationId.split('-')[1]}`; // Coerce to html to parse HTML code e.g. &#38; and return text node

  return htmlToHast(`<span class="${((_options$inlineClass = options.inlineClass) != null ? _options$inlineClass : []).join(' ')}" id=${ids}>${result[1]}</span>`);
};
/**
 * Generate bibliography in html and convert it to hast
 *
 * @param {*} citeproc
 */


const genBiblioNode = citeproc => {
  const [params, bibBody] = citeproc.makeBibliography();
  const bibliography = '<div id="refs" class="references csl-bib-body">\n' + bibBody.join('') + '</div>';
  const biblioNode = htmlToHast(bibliography); // Add citekey id to each bibliography entry.

  biblioNode.children.filter(node => {
    var _node$properties, _node$properties$clas;

    return (_node$properties = node.properties) == null ? void 0 : (_node$properties$clas = _node$properties.className) == null ? void 0 : _node$properties$clas.includes('csl-entry');
  }).forEach((node, i) => {
    const citekey = params.entry_ids[i][0].toLowerCase();
    node.properties = node.properties || {};
    node.properties.id = 'bib-' + citekey;
  });
  return biblioNode;
};
/**
 * Rehype plugin that formats citations in markdown documents and insert bibliography in html format
 *
 *    [-@wadler1990]                              --> (1990)
 *    [@hughes1989, sec 3.4]                      --> (Hughes 1989, sec 3.4)
 *    [see @wadler1990; and @hughes1989, pp. 4]   --> (see Wadler 1990 and Hughes 1989, pp. 4)
 *
 * @param {*} Cite cite object from citation-js configured with the required CSLs
 * @return {import('unified').Plugin<[Options?], Root>}
 */


const rehypeCitationGenerator = Cite => {
  return (options = {}) => {
    return async (tree, file) => {
      var _file$data, _file$data$frontmatte, _options$inlineBibCla;

      let bibliography = await getBibliography(options, file);

      if (!bibliography) {
        return;
      }
      /** @type {string} */


      let bibtexFile;
      /** @type {string} */
      // @ts-ignore

      const inputCiteformat = options.csl || (file == null ? void 0 : (_file$data = file.data) == null ? void 0 : (_file$data$frontmatte = _file$data.frontmatter) == null ? void 0 : _file$data$frontmatte.csl) || defaultCiteFormat;
      const inputLang = options.lang || 'en-US';
      const config = Cite.plugins.config.get('@csl');
      const citeFormat = await loadCSL(Cite, inputCiteformat, options.path);
      const lang = await loadLocale(Cite, inputLang, options.path);

      if (isValidHttpUrl(bibliography)) {
        const response = await fetch(bibliography);
        bibtexFile = await response.text();
      } else {
        {
          bibtexFile = await readFile(bibliography);
        }
      }

      const citations = new Cite(bibtexFile);
      const citationIds = citations.data.map(x => x.id);
      const citationPre = [];
      let citationId = 1;
      const citeproc = config.engine(citations.data, citeFormat, lang, 'html');
      visit(tree, 'text', (node, idx, parent) => {
        const match = node.value.match(citeExtractorRe); //@ts-ignore

        if (!match || !permittedTags.includes(parent.tagName)) return;
        const citeStartIdx = match.index;
        const citeEndIdx = match.index + match[0].length;
        const newChildren = []; // if preceding string

        if (citeStartIdx !== 0) {
          // create a new child node
          newChildren.push({
            type: 'text',
            value: node.value.slice(0, citeStartIdx)
          });
        }

        const [properties, entries] = parseCitation(match[0]); // If id is not in citation file (e.g. route alias or js package), abort process

        for (const citeItem of entries) {
          if (!citationIds.includes(citeItem.id)) return;
        }

        const citedTextNode = genCitation(citeproc, entries, `CITATION-${citationId}`, citationPre, options, properties); // Prepare citationPre and citationId for the next cite instance

        citationPre.push([`CITATION-${citationId}`, 0]);
        citationId = citationId + 1; // TODO: return html with link

        newChildren.push(citedTextNode); // if trailing string

        if (citeEndIdx < node.value.length) {
          newChildren.push({
            type: 'text',
            value: node.value.slice(citeEndIdx)
          });
        } // insert into the parent


        parent.children = [...parent.children.slice(0, idx), ...newChildren, ...parent.children.slice(idx + 1)];
      });

      if (options.noCite) {
        citeproc.updateItems(options.noCite.map(x => x.replace('@', '')));
      }

      if (citeproc.registry.mylist.length >= 1 && (!options.suppressBibliography || ((_options$inlineBibCla = options.inlineBibClass) == null ? void 0 : _options$inlineBibCla.length) > 0)) {
        const biblioNode = genBiblioNode(citeproc);
        let bilioInserted = false;
        const biblioMap = {};
        biblioNode.children.filter(node => {
          var _node$properties2, _node$properties2$cla;

          return (_node$properties2 = node.properties) == null ? void 0 : (_node$properties2$cla = _node$properties2.className) == null ? void 0 : _node$properties2$cla.includes('csl-entry');
        }).forEach(node => {
          const citekey = node.properties.id.split('-').slice(1).join('-');
          biblioMap[citekey] = _extends({}, node);
          biblioMap[citekey].properties = {
            id: 'inlinebib-' + citekey
          };
        }); // Insert it at ^ref, if not found insert it as the last element of the tree

        visit(tree, 'element', (node, idx, parent) => {
          var _options$inlineBibCla2, _node$properties3, _node$properties3$id;

          // Add inline bibliography
          if (((_options$inlineBibCla2 = options.inlineBibClass) == null ? void 0 : _options$inlineBibCla2.length) > 0 && (_node$properties3 = node.properties) != null && (_node$properties3$id = _node$properties3.id) != null && _node$properties3$id.toString().startsWith('citation-')) {
            // id is citation--nash1951--nash1950--1
            const [, ...citekeys] = node.properties.id.toString().split('--');
            const citationID = citekeys.pop();
            const inlineBibNode = {
              type: 'element',
              tagName: 'div',
              properties: {
                className: options.inlineBibClass,
                id: `inlineBib--${citekeys.join('--')}--${citationID}`
              },
              children: citekeys.map(citekey => {
                const aBibNode = biblioMap[citekey];
                aBibNode.properties = {
                  class: 'inline-entry',
                  id: `inline--${citekey}--${citationID}`
                };
                return aBibNode;
              })
            };
            parent.children.push(inlineBibNode);
          } // Add bibliography


          if (!options.suppressBibliography && (node.tagName === 'p' || node.tagName === 'div') && node.children[0].value === '[^ref]') {
            parent.children[idx] = biblioNode;
            bilioInserted = true;
          }
        });

        if (!options.suppressBibliography && !bilioInserted) {
          tree.children.push(biblioNode);
        }
      }
    };
  };
};

export { rehypeCitationGenerator as default };
//# sourceMappingURL=generator.mjs.map
