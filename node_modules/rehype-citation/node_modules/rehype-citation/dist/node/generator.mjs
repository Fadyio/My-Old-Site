import { visit } from 'unist-util-visit';
import fetch from 'cross-fetch';
import parse5 from 'parse5';
import { fromParse5 } from 'hast-util-from-parse5';

/**
 * Captures normal citation in square bracket and in-text citation
 * Citation key start should start with a letter, digit, or _,
 * and contains only alphanumerics and single internal punctuation characters (:.#$%&-+?<>~/),
 *
 * e.g. [-@wadler1990], [@hughes1989, sec 3.4], [see @wadler1990; and @hughes1989, pp. 4]
 * and @wadler1990
 *
 * Group #1 - citation term without [] bracket e.g. -@wadler1990
 * Group #2 - in-text citation term e.g. @wadler1990
 *
 * \[([^[\]]*@[^[\]]+)\] for group #1
 * (?!\b)@([a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\-+?<>~]*) for group #2
 * Use (?!\b) to avoid email like address e.g. xyx@google.com
 * */
const citeExtractorRe = /\[([^[\]]*@[^[\]]+)\]|(?!\b)(@[a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\-+?<>~]*)/;
const citeKeyRe = /@([a-zA-Z0-9_][a-zA-Z0-9_:.#$%&\-+?<>~]*)/;
const citeBracketRe = /\[.*\]/;

/**
 * @typedef CiteItem
 *   Cite item to be passed into citeproc-js
 * @property {string} [id]
 *   The id field is required
 * @property {string} [locator]
 *   A string identifying a page number or other pinpoint location or range within the resource;
 * @property {string} [label]
 *   Path to file
 * @property {string} [prefix]
 *   A string to print before this cite item
 * @property {string} [suffix]
 *   A string to print after this cite item
 * @property {boolean} [suppress-author]
 *   If true, author names will not be included in the citation output for this cite
 * @property {boolean} [author-only]
 *   If true, only the author name will be included in the citation output for this cite
 */
const locatorMapping = {
  book: 'book',
  'bk.': 'book',
  'bks.': 'book',
  chapter: 'chapter',
  'chap.': 'chapter',
  'chaps.': 'chapter',
  column: 'column',
  'col.': 'column',
  'cols.': 'column',
  figure: 'figure',
  'fig.': 'figure',
  'figs.': 'figure',
  folio: 'folio',
  'fol.': 'folio',
  'fols.': 'folio',
  number: 'number',
  'no.': 'number',
  'nos.': 'number',
  line: 'line',
  'l.': 'line',
  'll.': 'line',
  note: 'note',
  'n.': 'note',
  'nn.': 'note',
  opus: 'opus',
  'op.': 'opus',
  'opp.': 'opus',
  page: 'page',
  'p.': 'page',
  'pp.': 'page',
  paragraph: 'paragraph',
  'para.': 'paragraph',
  'paras.': 'paragraph',
  part: 'part',
  'pt.': 'part',
  'pts.': 'part',
  section: 'section',
  'sec.': 'section',
  'secs.': 'section',
  'sub verbo': 'sub verbo',
  's.v.': 'sub verbo',
  's.vv.': 'sub verbo',
  verse: 'verse',
  'v.': 'verse',
  'vv.': 'verse',
  volume: 'volume',
  'vol.': 'volume',
  'vols.': 'volume',
  '¶': 'paragraph',
  '¶¶': 'paragraph',
  '§': 'section',
  '§§': 'section'
};
/**
 * Parses a given citation string and return properties and entries required for cite-proc.
 * Adapted from https://github.com/Zettlr/Citr/blob/master/lib/citr.ts
 *
 * @param {string} citeString Cite string in the form of '[@item]' or '@item'
 * @return {[Object, CiteItem[]]} [properties, entries]
 */

const parseCitation = citeString => {
  /** @type {CiteItem[]} */
  let entries = [];
  let properties;

  if (citeBracketRe.test(citeString)) {
    properties = {
      noteIndex: 0
    }; // Handle citations in the form of [@item1; @item2]

    const citeItems = citeString.substr(1, citeString.length - 2).split(';');

    for (const citeItem of citeItems) {
      // Prefix is the portion before @ e.g. [see @item1] or an empty string
      let prefix = '';
      let locator = '';
      let label = 'page';
      let suffix = '';
      const citeChunk = citeItem.split('@');

      if (citeChunk.length === 1) {
        throw new Error('Cite key should be in the form of @key');
      } else if (citeChunk.length > 2) {
        throw new Error('More than one cite key @ detected, please separate keys with ;');
      }

      prefix += citeChunk[0];
      prefix = prefix.trim(); // If [-@item1], suppress author

      let suppressAuthor = citeItem.indexOf('@') > 0 && citeItem[citeItem.indexOf('@') - 1] === '-';
      if (suppressAuthor) prefix = prefix.substr(0, prefix.length - 1).trim(); // The citation key can be terminated with a comma or space

      let commaIndex = citeChunk[1].indexOf(',') + 1; // If the commaIndex is 0, this means there was no comma - check for space

      if (commaIndex === 0) commaIndex = citeChunk[1].indexOf(' ') + 1; // Pass undefined to extract everything

      if (commaIndex <= 0) commaIndex = undefined;
      const citeKey = citeItem.substr(citeItem.indexOf('@'), commaIndex).match(citeKeyRe)[0]; // We are left with the locator, suffix and label

      let afterKey = citeItem.split('@')[1].substr(citeKey.length).trim();
      if (afterKey[0] === ',') afterKey = afterKey.substr(1).trim(); // Locator should be in the form of 11-22, 33
      // Would not work form roman numerals or alphabetical sections

      const locatorMatch = afterKey.match(/(\d|-| |,)+/g);

      if (locatorMatch !== null) {
        locator = locatorMatch[0].trim(); // String before the locator is taken to be the label
        // Use heuristic from https://pandoc.org/MANUAL.html#citation-syntax to convert locator label to valid
        // Label has to be one of the following: https://docs.citationstyles.org/en/stable/specification.html#locators

        label = afterKey.split(locator)[0].trim();
        label = locatorMapping[label] || 'page'; // String after the locator is taken to be the suffix

        suffix = afterKey.split(locator)[1].trim();
      } else {
        // If no locator is found, entire string is assumed to be the suffix
        suffix = afterKey.trim();
      }

      entries.push({
        // Get the first capture group which returns the citekey without @
        id: citeItem.match(citeKeyRe)[1],
        locator,
        label,
        prefix,
        suffix,
        'suppress-author': suppressAuthor
      });
    }
  } else {
    // Single item in the form of @item1
    // See https://citeproc-js.readthedocs.io/en/latest/running.html#special-citation-forms
    properties = {
      noteIndex: 0,
      mode: 'composite'
    };
    entries = [citeString].map(str => ({
      id: str.match(citeKeyRe)[1]
    }));
  }

  return [properties, entries];
};

const readFile = async path => {
  if (isValidHttpUrl(path)) {
    return fetch(path).then(response => response.text()).then(data => data);
  } else {
    {
      return import('fs').then(fs => fs.readFileSync(path, 'utf8'));
    }
  }
};
/**
 * Check if valid URL
 * https://stackoverflow.com/questions/5717093/check-if-a-javascript-string-is-a-url
 *
 * @param {string} str
 * @return {boolean}
 */

const isValidHttpUrl = str => {
  let url;

  try {
    url = new URL(str);
  } catch (_) {
    return false;
  }

  return url.protocol === 'http:' || url.protocol === 'https:';
};
/**
 * Get bibliography by merging options and vfile data
 *
 * @param {import('./generator.js').Options} options
 * @param {import('vfile').VFile} file
 */

const getBibliography = async (options, file) => {
  var _file$data, _file$data$frontmatte;

  let bibliography = '';

  if (options.bibliography) {
    bibliography = options.bibliography; // @ts-ignore
  } else if (file != null && (_file$data = file.data) != null && (_file$data$frontmatte = _file$data.frontmatter) != null && _file$data$frontmatte.bibliography) {
    // @ts-ignore
    bibliography = file.data.frontmatter.bibliography; // If local path, get absolute path

    if (!isValidHttpUrl(bibliography)) {
      {
        bibliography = await import('path').then(path => path.join(options.path || file.cwd, bibliography));
      }
    }
  }

  return bibliography;
};

/**
 * Convert HTML to HAST node
 *
 * @param {string} html
 */

const htmlToHast = html => {
  const p5ast = parse5.parseFragment(html);
  return fromParse5(p5ast).children[0];
};

/**
 * @typedef {import('hast').Node} Node
 * @typedef {import('hast').Parent} Parent
 * @typedef {import('hast').Root} Root
 * @typedef {import('unist-util-visit').Visitor<Node>} Visitor
 * @typedef {import('./parse-citation').CiteItem} CiteItem
 * @typedef Options
 *   Configuration.
 * @property {string} [bibliography]
 *   Name of bibtex or CSL-JSON file
 * @property {string} [path]
 *   Optional path to file (node). Will be joined with `options.bibliography` and used in place of cwd of file if provided.
 * @property {'apa'|'vancouver'|'harvard1'|'chicago'|'mla'|string} [csl]
 *   One of 'apa', 'vancouver', 'harvard1', 'chicago', 'mla' or name of the local csl file
 * @property {string} [lang]
 *   Locale to use in formatting citations. Defaults to en-US.
 * @property {boolean} [suppressBibliography]
 *   By default, biliography is inserted after the entire markdown file.
 *   If the file contains `[^Ref]`, the biliography will be inserted there instead.
 * @property {string[]} [noCite]
 *   Citation IDs (@item1) to include in the bibliography even if they are not cited in the document
 */
const defaultCiteFormat = 'apa';
const permittedTags = ['div', 'p', 'span', 'li'];
/**
 * Generate citation using citeproc
 * This accounts for prev citations and additional properties
 *
 * @param {*} citeproc
 * @param {CiteItem[]} entries
 * @param {string} citationId
 * @param {any[]} citationPre
 * @param {*} [properties={ noteIndex: 0 }]
 * @return {*}
 */

const genCitation = (citeproc, entries, citationId, citationPre, properties = {
  noteIndex: 0
}) => {
  const c = citeproc.processCitationCluster({
    citationID: citationId,
    citationItems: entries,
    properties: properties
  }, citationPre.length > 0 ? citationPre : [], []); // c = [ { bibchange: true, citation_errors: [] }, [ [ 0, '(1)', 'CITATION-1' ] ]]

  const result = c[1].filter(x => x[2] === citationId); // Coerce to html to parse HTML code e.g. &#38; and return text node

  const citeNode = htmlToHast(`<div>${result[0][1]}</div>`);
  const textNode = citeNode.children[0];
  return textNode;
};
/**
 * Generate bibliography in html and convert it to hast
 *
 * @param {*} citeproc
 */


const genBiblioNode = citeproc => {
  const [, bibBody] = citeproc.makeBibliography();
  const bibliography = '<div id="refs" class="references csl-bib-body">\n' + bibBody.join('') + '</div>';
  const biblioNode = htmlToHast(bibliography);
  return biblioNode;
};
/**
 * Rehype plugin that formats citations in markdown documents and insert bibliography in html format
 *
 *    [-@wadler1990]                              --> (1990)
 *    [@hughes1989, sec 3.4]                      --> (Hughes 1989, sec 3.4)
 *    [see @wadler1990; and @hughes1989, pp. 4]   --> (see Wadler 1990 and Hughes 1989, pp. 4)
 *
 * @param {*} Cite cite object from citation-js configured with the required CSLs
 * @return {import('unified').Plugin<[Options?], Root>}
 */


const rehypeCitationGenerator = Cite => {
  return (options = {}) => {
    return async (tree, file) => {
      var _file$data, _file$data$frontmatte;

      let bibliography = await getBibliography(options, file);

      if (!bibliography) {
        return;
      }
      /** @type {string} */


      let bibtexFile;
      /** @type {string} */
      // @ts-ignore

      const citeFormat = options.csl || (file == null ? void 0 : (_file$data = file.data) == null ? void 0 : (_file$data$frontmatte = _file$data.frontmatter) == null ? void 0 : _file$data$frontmatte.csl) || defaultCiteFormat;

      if (isValidHttpUrl(bibliography)) {
        const response = await fetch(bibliography);
        bibtexFile = await response.text();
      } else {
        {
          bibtexFile = await readFile(bibliography);
        }
      }

      const citations = new Cite(bibtexFile);
      const citationIds = citations.data.map(x => x.id);
      const citationPre = [];
      let citationId = 1;
      const config = Cite.plugins.config.get('@csl');
      const citeproc = config.engine(citations.data, citeFormat, options.lang || 'en-US', 'html');
      visit(tree, 'text', (node, idx, parent) => {
        const match = node.value.match(citeExtractorRe); //@ts-ignore

        if (!match || !permittedTags.includes(parent.tagName)) return;
        const citeStartIdx = match.index;
        const citeEndIdx = match.index + match[0].length;
        const newChildren = []; // if preceding string

        if (citeStartIdx !== 0) {
          // create a new child node
          newChildren.push({
            type: 'text',
            value: node.value.slice(0, citeStartIdx)
          });
        }

        const [properties, entries] = parseCitation(match[0]); // If id is not in citation file (e.g. route alias or js package), abort process

        for (const citeItem of entries) {
          if (!citationIds.includes(citeItem.id)) return;
        }

        const citedTextNode = genCitation(citeproc, entries, `CITATION-${citationId}`, citationPre, properties); // Prepare citationPre and citationId for the next cite instance

        citationPre.push([`CITATION-${citationId}`, 0]);
        citationId = citationId + 1; // TODO: return html with link

        newChildren.push(citedTextNode); // if trailing string

        if (citeEndIdx < node.value.length) {
          newChildren.push({
            type: 'text',
            value: node.value.slice(citeEndIdx)
          });
        } // insert into the parent


        parent.children = [...parent.children.slice(0, idx), ...newChildren, ...parent.children.slice(idx + 1)];
      });

      if (options.noCite) {
        citeproc.updateItems(options.noCite.map(x => x.replace('@', '')));
      }

      if (!options.suppressBibliography && citeproc.registry.mylist.length >= 1) {
        const biblioNode = genBiblioNode(citeproc);
        let bilioInserted = false; // Insert it at ^ref, if not found insert it as the last element of the tree

        visit(tree, 'element', (node, idx, parent) => {
          if ((node.tagName === 'p' || node.tagName === 'div') && node.children[0].value === '[^ref]') {
            parent.children[idx] = biblioNode;
            bilioInserted = true;
          }
        });

        if (!bilioInserted) {
          tree.children.push(biblioNode);
        }
      }
    };
  };
};

export { rehypeCitationGenerator as default };
//# sourceMappingURL=generator.mjs.map
